(()=>{"use strict";var t={7503:(t,e,r)=>{r.r(e),r.d(e,{default:()=>E});var i=Object.defineProperty,s=(t,e,r)=>(((t,e,r)=>{e in t?i(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r})(t,"symbol"!=typeof e?e+"":e,r),r);const n={PI:Math.PI,E:Math.E,LN2:Math.LN2,LN10:Math.LN10,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,SQRT1_2:Math.SQRT1_2,SQRT2:Math.SQRT2};class o{static throwIfNotNumber(t){if("string"==typeof t)throw new Error("Strings are not allowed in math operations")}}class a{static throwIfNotNumber(t){if("string"==typeof t)throw new Error("Strings are not allowed in math operations")}}class h{static createOperatorExpression(t,e,r){if("^"===t)return new f(e,r);if(["*","/"].includes(t))return new c(t,e,r);if(["+","-"].includes(t))return new p(t,e,r);if(["<",">","<=",">=","=","!="].includes(t))return new w(t,e,r);throw new Error(`Unknown operator: ${t}`)}evaluate(t={}){throw new Error("Empty Expression - Must be defined in child classes")}toString(){return""}}class l extends h{constructor(t){if(super(),s(this,"innerExpression"),this.innerExpression=t,!(this.innerExpression instanceof h))throw new Error("No inner expression given for bracket expression")}evaluate(t={}){return this.innerExpression.evaluate(t)}toString(){return`(${this.innerExpression.toString()})`}}class u extends h{constructor(t,e="number"){switch(super(),s(this,"value"),s(this,"type"),this.value=Number(t),e){case"number":if(this.value=Number(t),isNaN(this.value))throw new Error("Cannot parse number: "+t);break;case"string":this.value=String(t);break;default:throw new Error("Invalid value type: "+e)}this.type=e}evaluate(){return this.value}toString(){switch(this.type){case"number":return String(this.value);case"string":return'"'+this.value+'"';default:throw new Error("Invalid type")}}}class p extends h{constructor(t,e,r){if(super(),s(this,"operator"),s(this,"left"),s(this,"right"),!["+","-"].includes(t))throw new Error(`Operator not allowed in Plus/Minus expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){const e=this.left.evaluate(t),r=this.right.evaluate(t);if(o.throwIfNotNumber(e),o.throwIfNotNumber(r),"+"===this.operator)return Number(e)+Number(r);if("-"===this.operator)return Number(e)-Number(r);throw new Error("Unknown operator for PlusMinus expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class c extends h{constructor(t,e,r){if(super(),s(this,"operator"),s(this,"left"),s(this,"right"),!["*","/"].includes(t))throw new Error(`Operator not allowed in Multiply/Division expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){const e=this.left.evaluate(t),r=this.right.evaluate(t);if(o.throwIfNotNumber(e),o.throwIfNotNumber(r),"*"===this.operator)return Number(e)*Number(r);if("/"===this.operator)return Number(e)/Number(r);throw new Error("Unknown operator for MultDiv expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class f extends h{constructor(t,e){super(),s(this,"base"),s(this,"exponent"),this.base=t,this.exponent=e}evaluate(t={}){const e=this.base.evaluate(t),r=this.exponent.evaluate(t);return o.throwIfNotNumber(e),o.throwIfNotNumber(r),Math.pow(Number(e),Number(r))}toString(){return`${this.base.toString()}^${this.exponent.toString()}`}}class w extends h{constructor(t,e,r){if(super(),s(this,"operator"),s(this,"left"),s(this,"right"),!["<",">","<=",">=","=","!="].includes(t))throw new Error(`Operator not allowed in Logical expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){const e=this.left.evaluate(t),r=this.right.evaluate(t);switch(this.operator){case"<":return e<r?1:0;case">":return e>r?1:0;case"<=":return e<=r?1:0;case">=":return e>=r?1:0;case"=":return e===r?1:0;case"!=":return e!==r?1:0}throw new Error("Unknown operator for Logical expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}class m extends h{constructor(t,e,r=null){super(),s(this,"fn"),s(this,"varPath"),s(this,"argumentExpressions"),s(this,"formulaObject"),s(this,"blacklisted"),this.fn=null!=t?t:"",this.varPath=this.fn.split("."),this.argumentExpressions=e||[],this.formulaObject=r,this.blacklisted=void 0}evaluate(t={}){var e;t=t||{};const r=this.argumentExpressions.map((e=>e.evaluate(t)));try{let e=g(t,this.varPath,this.fn);if(e instanceof Function)return e.apply(this,r)}catch(t){}let i;try{i=g(null!=(e=this.formulaObject)?e:{},this.varPath,this.fn)}catch(t){}if(this.formulaObject&&i instanceof Function){if(this.isBlacklisted())throw new Error("Blacklisted function called: "+this.fn);return i.apply(this.formulaObject,r)}try{const t=g(Math,this.varPath,this.fn);if(t instanceof Function)return r.forEach((t=>{a.throwIfNotNumber(t)})),t.apply(this,r)}catch(t){}throw new Error("Function not found: "+this.fn)}toString(){return`${this.fn}(${this.argumentExpressions.map((t=>t.toString())).join(", ")})`}isBlacklisted(){return void 0===this.blacklisted&&(this.blacklisted=E.functionBlacklist.includes(this.formulaObject?this.formulaObject[this.fn]:null)),this.blacklisted}}function g(t,e,r){let i=t;for(let t of e){if("object"!=typeof i)throw new Error(`Cannot evaluate ${t}, property not found (from path ${r})`);if(void 0===i[t])throw new Error(`Cannot evaluate ${t}, property not found (from path ${r})`);i=i[t]}if("object"==typeof i)throw new Error("Invalid value");return i}class b extends h{constructor(t,e=null){super(),s(this,"fullPath"),s(this,"varPath"),s(this,"formulaObject"),this.formulaObject=e,this.fullPath=t,this.varPath=t.split(".")}evaluate(t={}){var e;let r;try{r=g(t,this.varPath,this.fullPath)}catch(t){}if(void 0===r&&(r=g(null!=(e=this.formulaObject)?e:{},this.varPath,this.fullPath)),"function"==typeof r||"object"==typeof r)throw new Error(`Cannot use ${this.fullPath} as value: It contains a non-numerical value.`);return r}toString(){return`${this.varPath.join(".")}`}}const v=class t{constructor(t,e={}){s(this,"formulaExpression"),s(this,"options"),s(this,"formulaStr"),s(this,"_variables"),s(this,"_memory"),this.formulaExpression=null,this.options={memoization:!1,...e},this.formulaStr="",this._variables=[],this._memory={},this.setFormula(t)}setFormula(t){return t&&(this.formulaExpression=null,this._variables=[],this._memory={},this.formulaStr=t,this.formulaExpression=this.parse(t)),this}enableMemoization(){this.options.memoization=!0}disableMemoization(){this.options.memoization=!1,this._memory={}}splitFunctionParams(t){let e=0,r="";const i=[];for(let s of t.split(""))if(","===s&&0===e)i.push(r),r="";else if("("===s)e++,r+=s;else if(")"===s){if(e--,r+=s,e<0)throw new Error("ERROR: Too many closing parentheses!")}else r+=s;if(0!==e)throw new Error("ERROR: Too many opening parentheses!");return r.length>0&&i.push(r),i}cleanupInputFormula(t){const e=[];return t.split('"').forEach(((t,r)=>{r%2==0&&(t=t.replace(/[\s]+/g,""),Object.keys(n).forEach((e=>{t=t.replace(new RegExp(`\\b${e}\\b`,"g"),`[${e}]`)}))),e.push(t)})),e.join('"')}parse(t){return t=this.cleanupInputFormula(t),this._do_parse(t)}_do_parse(t){let e=t.length-1,r=0,i="initial",s=[],n="",o="",a=null,p=0,c="";for(;r<=e;){switch(i){case"initial":if(n=t.charAt(r),n.match(/[0-9.]/))i="within-nr",o="",r--;else if(this.isOperator(n)){if("-"===n&&(0===s.length||this.isOperatorExpr(s[s.length-1]))){i="within-nr",o="-";break}if(r===e||this.isOperatorExpr(s[s.length-1])){i="invalid";break}s.push(h.createOperatorExpression(n,new h,new h)),i="initial"}else if([">","<","=","!"].includes(n)){if(r===e){i="invalid";break}i="within-logical-operator",o=n}else"("===n?(i="within-parentheses",o="",p=0):"["===n?(i="within-named-var",o=""):n.match(/["']/)?(i="within-string",c=n,o=""):n.match(/[a-zA-Z]/)&&(r<e&&t.charAt(r+1).match(/[a-zA-Z0-9_.]/)?(o=n,i="within-func"):(s.length>0&&s[s.length-1]instanceof u&&s.push(h.createOperatorExpression("*",new h,new h)),s.push(new b(n,this)),this.registerVariable(n),i="initial",o=""));break;case"within-nr":n=t.charAt(r),n.match(/[0-9.]/)?(o+=n,r===e&&(s.push(new u(o)),i="initial")):("-"===o&&(o="-1"),s.push(new u(o)),o="",i="initial",r--);break;case"within-func":if(n=t.charAt(r),n.match(/[a-zA-Z0-9_.]/))o+=n;else{if("("!==n)throw new Error("Wrong character for function at position "+r);a=o,o="",p=0,i="within-func-parentheses"}break;case"within-named-var":if(n=t.charAt(r),"]"===n)s.push(new b(o,this)),this.registerVariable(o),o="",i="initial";else{if(!n.match(/[a-zA-Z0-9_.]/))throw new Error("Character not allowed within named variable: "+n);o+=n}break;case"within-string":n=t.charAt(r),n===c?(s.push(new u(o,"string")),o="",i="initial",c=""):o+=n;break;case"within-parentheses":case"within-func-parentheses":if(n=t.charAt(r),c)n===c&&(c=""),o+=n;else if(")"===n)if(p<=0){if("within-parentheses"===i)s.push(new l(this._do_parse(o)));else if("within-func-parentheses"===i){let t=this.splitFunctionParams(o).map((t=>this._do_parse(t)));s.push(new m(a,t,this)),a=null}i="initial"}else p--,o+=n;else"("===n?(p++,o+=n):(n.match(/["']/)&&(c=n),o+=n);break;case"within-logical-operator":n=t.charAt(r),"="===n&&(o+=n,r++),s.push(h.createOperatorExpression(o,new h,new h)),o="",i="initial",r--}r++}if("initial"!==i)throw new Error("Could not parse formula: Syntax error.");return this.buildExpressionTree(s)}buildExpressionTree(t){if(t.length<1)throw new Error("No expression given!");const e=[...t];let r=0,i=null;for(;r<e.length;)if(i=e[r],i instanceof f){if(0===r||r===e.length-1)throw new Error("Wrong operator position!");i.base=e[r-1],i.exponent=e[r+1],e[r-1]=i,e.splice(r,2)}else r++;for(r=0,i=null;r<e.length;)if(i=e[r],i instanceof c){if(0===r||r===e.length-1)throw new Error("Wrong operator position!");i.left=e[r-1],i.right=e[r+1],e[r-1]=i,e.splice(r,2)}else r++;for(r=0,i=null;r<e.length;)if(i=e[r],i instanceof p){if(0===r||r===e.length-1)throw new Error("Wrong operator position!");i.left=e[r-1],i.right=e[r+1],e[r-1]=i,e.splice(r,2)}else r++;for(r=0,i=null;r<e.length;)if(i=e[r],i instanceof w){if(0===r||r===e.length-1)throw new Error("Wrong operator position!");i.left=e[r-1],i.right=e[r+1],e[r-1]=i,e.splice(r,2)}else r++;if(1!==e.length)throw new Error("Could not parse formula: incorrect syntax?");return e[0]}isOperator(t){return"string"==typeof t&&t.match(/[+\-*/^]/)}isOperatorExpr(t){return t instanceof p||t instanceof c||t instanceof f||t instanceof w}registerVariable(t){this._variables.indexOf(t)<0&&this._variables.push(t)}getVariables(){return this._variables}evaluate(t){if(t instanceof Array)return t.map((t=>this.evaluate(t)));let e=this.getExpression();if(!(e instanceof h))throw new Error("No expression set: Did you init the object with a Formula?");if(this.options.memoization){let r=this.resultFromMemory(t);return null!==r||(r=e.evaluate({...n,...t}),this.storeInMemory(t,r)),r}return e.evaluate({...n,...t})}hashValues(t){return JSON.stringify(t)}resultFromMemory(t){let e=this.hashValues(t),r=this._memory[e];return void 0!==r?r:null}storeInMemory(t,e){this._memory[this.hashValues(t)]=e}getExpression(){return this.formulaExpression}getExpressionString(){return this.formulaExpression?this.formulaExpression.toString():""}static calc(e,r=null,i={}){return r=null!=r?r:{},new t(e,i).evaluate(r)}};s(v,"Expression",h),s(v,"BracketExpression",l),s(v,"PowerExpression",f),s(v,"MultDivExpression",c),s(v,"PlusMinusExpression",p),s(v,"LogicalExpression",w),s(v,"ValueExpression",u),s(v,"VariableExpression",b),s(v,"FunctionExpression",m),s(v,"MATH_CONSTANTS",n),s(v,"functionBlacklist",Object.getOwnPropertyNames(v.prototype).filter((t=>v.prototype[t]instanceof Function)).map((t=>v.prototype[t])));let E=v}},e={};function r(i){var s=e[i];if(void 0!==s)return s.exports;var n=e[i]={exports:{}};return t[i](n,n.exports,r),n.exports}r.d=(t,e)=>{for(var i in e)r.o(e,i)&&!r.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var i={};(()=>{var t=i;Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"Formula",{enumerable:!0,get:function(){return e.default}});var e=s(r(7503));function s(t){return t&&t.__esModule?t:{default:t}}})(),window.BrizyLibs=i})();